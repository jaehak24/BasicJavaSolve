객체지향 프로그래밍의 4개의 기둥
상속
캡슐화
다형성
추상화

extends 키워드를 통해 두 클래스 간 상속 관계를 정의
상속 관계에서 사용할 수 있는 메서드 오버라이딩, 성립 조건, 장점을 이해
super와 super()의 차이

Java에서 상속이란 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법이다.
즉, 상위 클래스에서 정의한 메서드, 이너 클래스, 필드 등을 하위 클래스로 공유 하는 개념이다. 

상속 개념을 이헤할 때는 자손 부모 관계를 중시하기 보다는 extends 키워들를 통한 확장의 개념으로 보는 것이 더 바람직하다.

(상속 코드 예시)

또, 자바만의 특징으로 다른 C계열의 언어와는 달리 단일 상속만을 허용한다. 즉, extends에 여러 가지 클래스를 넣을 수 없다.

메서드 오버라이딩
앞서 말한 상위 클래스에서 정의한 메서드를 하위 클래스에서 별도의 정의 없이 사용할 수 있다. 도 Java에서는 하위 클래스에서 임의로 상위 클래스의 변수를 오버라이딩 할 수 있다.
다음 코드를 보자.
(메서드 오버라이딩 예제)
상위 클래스에서 정의한 출력문을 하위 클래스에서 임의로 정의하면 하위 클래스에서 해당 메서드를 호출하면 다음과 같이 적절한 하위 클래스에서 정의한 방식대로 출력이 된다.


super와 super()

앞서 this와 this()를 구분했었다. this는 자기 객체를 호출할 때 사용, this() 메서드는 같은 클래스의 다른 생성자를 호출하는데 사용되고 생성자 내에서만 사용이 가능한 메서드다.

이번에 배울 super는 상위 객체를 호출하는 것, super() 자신의 생성자 호출을 얘기하는 것이다. 
(super 예시 코드)

코드에서 볼 수 있듯이 super는 상위 클래스의 객체로 작용한다.

(super() 메서드 예제)
위 예제에서 볼 수 있듯이 super()는 상위 클래스의 생성자 호출을 대신하고 있다.




Object 클래스
자바의 클래스 상속계층도에서 최상위층의 클래스를 지칭하는 말이다. 즉, 자바에서 작성하는 모든 코드는 object 클래스로부터 확장된 것이다. 
우리가 어떤 자바 코드를 extends 없이 사용하더라도 Java 컴파일러는 자동으로 extends 
Object를 하고 있는 것이다. 

Object에서 정의된 대표적 메서드
toString(): 객체 정보를 문자열로 반환
equals(Object obj): 스태 메모리값을 서로 비교
wait(): 현재 쓰레드 일시 정지
notify(): 일시정지 중인 쓰레드 재동작 
















캡슐화

캡슐화의 목적
데이터 보호
데이터의 불필요한 노출 방지

접근제어자 getter, setter 메서드에 대해서 집중적으로 학습하면 된다.


패키지: 특정한 목적을 공유하는 클래스 또는 interface

자바에서 패키지는 하나의 디렉토리이고, 이 디렉토리의 계층구조는 (.)으로 구분된다.

Import문 
우리가 Java 입력문을 사용하기 위해서는 Scanner라는 패키지를 import해서 사용해야 된다. 
예를 들어 데이터의 간편화를 위해서 Scanner 클래스의 test라는 클래스만 import하고 싶다면 

import Scanner.test; 이렇게 해주면 된다.

만약 Scanner 클래스 밑의 모든 클래스를 사용하고 싶다면 

Import Scanner;
Import Scanner.test; 이렇게 해주면 된다.


접근 제어자
private: 동일 클래스에서만 접근 가능
default: 동일 패키지 내에서만 접근 가능
protected: 동일 패키지+ 다른 패키지의 하위 클래스에서 접근 가능
public: 접근 제한 없음


getter setter 메서드

클래스를 private으로 설정하면 다른 클래스에서 해당 클래스를 참조하여 값을 변경하는 것이 불가능하다. 하지만 getter, setter 메서드를 사용하면 가능하다.

(getter,setter 메서드 예제 코드)

getter 메서드: 다른 클래스(참조 불가능 )에서 데이터를 참조
사용법 : get-을 메서드 앞에 붙여서 사용
setter 메서드: 다른 클래스가 클래스 값 안을 변경 가능하게 해줌
사용법 : set-을 메서드 앞에 붙여서 사용


ex> private 클래스에서 외부 클래스 데이터를 참조하고 싶을 때 getter
       private 클래스의 필드값을 사용하고 싶을 때 setter
       
       

다형성
객체가 여러 가지 형태(polymorph)를 가질 수 있는 특징을 말하는 것
자바에서는 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것


(객체 타입과 참조변수 타입이 불일치한 예시)

위에서 볼 수 있듯이 하위 클래스는 참조변수로 상위 클래스의 타입을 선언 할 수 있다. 하지만, 반대로 상위 클래스의 객체는 하위 클래스의 참조변수를 대상으로 할 수 없다.

참조변수의 타입 변환

앞서 말했듯이 Java에서는 상속 관계의 클래스는 다양한 형태의 참조변수를 가지는 특징을 가지고 있다고 설명했다. 그렇다면 왜 필요할까? 참조 변수를 여러 형태로 가진다는 얘기는 다른 말로 “사용할 수 있는 멤버의 개수를 조절할 수 있다.” 라고 할 수 있다. 
이를 위해서는 타입 변환 조건에 대해서 제대로 알아야 하는데 다음 세 가지는 타입 변환을 하기 위한 세 가지 조건이다.

서로 상속관계의 클래스들만 타입 변환을 할 수 있다.
하위 클래스 타입에서 상위 클래스 타입으로의 타입 변환은 형변환 연산자를 생략할 수 있다.
반대로 상위 클래스에서 하위 클래스 타입으로 변환(downcasting)은 형변환 연산자(괄호 표시)가 반드시 있어야 한다.

(타입 변환 예제)

위의 코드를 보면 알 수 있듯이 상위 클래스로 타입 변환하는 문장은 생략이 가능하고, 하위 클래스로의 타입 변환에는 괄호가 표시되어 있는 것을 알 수 있다.


instanceof 연산자

앞에서 배운 캐스팅(참조 변환)이 가능한 지 여부를 묻는 자바의 문법이다.

사용법 : 참조변수 instanceof 타입
반환: boolean

(코드 예제)

위의 출력문을 보면 true 또는 false 형태로 값을 반환하는 것을 볼 수 있다. 지금과 같은 짧은 코드에서는 의미가 없을 수 있지만 수백 개의 클래스로 이루어진 프로젝트에서는 모든 시트를 뒤지는 것보다는 instanceof 메소드를 통해서 참조관계를 확인하는 것이 시간을 줄일 수 있는 방법이다.

다형성의 활용 예제
(카페 예제 다른 제품으로 변환해서 작성)

추상화

사물의 공통성, 성질, 본질을 모아 추출하고 분류하는 것


Abstract 제어자

코딩을 하다 보면 클래스를 정의 하는 과정에서 알고리즘이 기억이 나지 않거나 아직 미완성으로 남겨야만 하는 클래스들이 가끔가다 생길 것이다. 이럴 때 우리는 abstract 제어자를 사용한다. 클래스나 메소드 앞에 abstract를 붙임에 따라 클래스나 바디가 완성되지 않았어도 해당 클래스나 메서드는 존재 할 수 있다. 하지만 abstract가 붙음에 따라 객체를 생성할 수 없다. 설계도가 완성되지 않았는데 제품을 만들 수 없듯이 abstract class는 객체를 생성할 수 없다. 그럼 왜 사용할까? 
상속 개념은 여전히 사용할 수 있다.
ex> human.arm 일때 arm의 human 클래스를 abstract로 설정하면 클래스를 완성시키지 않더라도 human 안의 필드 메서드를 사용할 수 있다.

final 키워드

final 키워드는 어디 앞에 붙느냐에 따라 다르기 때문에 구분할 필요가 있다.

클래스: 변경 또는 확장 불가능한 클래스, 상속 불가
메서드: 오버라이딩 불가
변수: 상수 정의

즉, 어떤 참조나 변경을 원하지 않는 데이터의 보안성을 위한 키워드다.


☆☆☆☆☆인터페이스☆☆☆☆☆

컴퓨터에서 인터(inter) 페이스(face)는 두 장치 or 프로그램 간을 이어주는 부분 or 접속장치를 말한다.

대표적인 예제로 GUI(Graphic User Interfacr)가 있다. 우리는 GUI를 통해 매일 명령어 입력 없이 컴퓨터를 활용 할 수 있다.
인터페이스의 기본 구조

class 대신 interface 키워드를 사용
내부의 모든 필드가 public static final로 정의
모든 메서드가 public abstract로 정의

예제
github
public interface InterFacePr {
   public static boolean drive=true;
   final int speed=40; // public static 생략
   static int weight=140; // public &final 생략

   public abstract void DrivingMode();
   void call(); //public abstract 생략
}

